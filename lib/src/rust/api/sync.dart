// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'sync.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ApiSyncProgress`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// 获取 WebDAV 设置
Future<ApiWebDavSettings> getWebdavSettings() =>
    RustLib.instance.api.crateApiSyncGetWebdavSettings();

/// 保存 WebDAV 设置
Future<bool> saveWebdavSettings({required ApiWebDavSettings settings}) =>
    RustLib.instance.api.crateApiSyncSaveWebdavSettings(settings: settings);

/// 测试 WebDAV 连接
Future<bool> testWebdavConnection({
  required String url,
  required String username,
  required String password,
}) => RustLib.instance.api.crateApiSyncTestWebdavConnection(
  url: url,
  username: username,
  password: password,
);

/// 执行同步
Future<ApiSyncStatus> syncHistory({required bool forceUpload}) =>
    RustLib.instance.api.crateApiSyncSyncHistory(forceUpload: forceUpload);

/// 强制上传本地历史到云端（覆盖）
Future<ApiSyncStatus> forceUploadHistory() =>
    RustLib.instance.api.crateApiSyncForceUploadHistory();

/// 清理过期的已删除历史记录
Future<PlatformInt64> cleanupExpiredHistory() =>
    RustLib.instance.api.crateApiSyncCleanupExpiredHistory();

/// 获取上次同步时间
Future<PlatformInt64?> getLastSyncTime() =>
    RustLib.instance.api.crateApiSyncGetLastSyncTime();

/// 更新上次同步时间
Future<bool> updateLastSyncTime() =>
    RustLib.instance.api.crateApiSyncUpdateLastSyncTime();

/// 检查是否需要自动同步
Future<bool> shouldAutoSync() =>
    RustLib.instance.api.crateApiSyncShouldAutoSync();

@freezed
sealed class ApiSyncStatus with _$ApiSyncStatus {
  const ApiSyncStatus._();

  /// 同步成功
  const factory ApiSyncStatus.success({
    required int mergedCount,
    required bool uploaded,
  }) = ApiSyncStatus_Success;

  /// 解密失败，需要用户确认
  const factory ApiSyncStatus.decryptionFailed() =
      ApiSyncStatus_DecryptionFailed;

  /// 需要输入新密钥
  const factory ApiSyncStatus.needNewKey() = ApiSyncStatus_NeedNewKey;

  /// 网络错误
  const factory ApiSyncStatus.networkError({required String message}) =
      ApiSyncStatus_NetworkError;

  /// 配置未设置
  const factory ApiSyncStatus.notConfigured() = ApiSyncStatus_NotConfigured;
}

/// WebDAV 设置
@freezed
sealed class ApiWebDavSettings with _$ApiWebDavSettings {
  const ApiWebDavSettings._();
  const factory ApiWebDavSettings({
    required String url,
    required String username,
    required String password,
    required String encryptionKey,
    required bool autoSyncOnStart,
    required int autoSyncInterval,
  }) = _ApiWebDavSettings;
  static Future<ApiWebDavSettings> default_() =>
      RustLib.instance.api.crateApiSyncApiWebDavSettingsDefault();
}
