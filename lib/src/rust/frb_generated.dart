// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/cache.dart';
import 'api/download.dart';
import 'api/download_folders.dart';
import 'api/init.dart';
import 'api/models.dart';
import 'api/search.dart';
import 'api/settings.dart';
import 'api/simple.dart';
import 'api/sync.dart';
import 'api/user.dart';
import 'api/video.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiSimpleInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => 665121268;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'rust_lib_hibiscus',
        ioDirectory: 'rust/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class RustLibApi extends BaseApi {
  Future<ApiDownloadTask> crateApiDownloadAddDownload({
    required String videoId,
    required String title,
    required String coverUrl,
    required String quality,
    String? description,
    required List<String> tags,
  });

  Future<bool> crateApiUserAddToFavorites({
    required String videoCode,
    required String formToken,
    required String xCsrfToken,
    required String userId,
  });

  Future<bool> crateApiVideoAddToFavorites({required String videoId});

  Future<ApiAppSettings> crateApiModelsApiAppSettingsDefault();

  Future<ApiSearchFilters> crateApiModelsApiSearchFiltersDefault();

  Future<ApiWebDavSettings> crateApiSyncApiWebDavSettingsDefault();

  Future<void> crateApiCacheAutoCleanCache({
    PlatformInt64? webExpireMs,
    PlatformInt64? imageExpireMs,
  });

  Future<CacheSize> crateApiCacheCacheSizeDefault();

  Future<bool> crateApiInitCheckCloudflare();

  Future<bool> crateApiInitCheckNetwork();

  Future<PlatformInt64> crateApiSyncCleanupExpiredHistory();

  Future<void> crateApiInitCleanupLogs({
    required String dataPath,
    BigInt? maxTotalBytes,
    int? maxFiles,
    PlatformInt64? maxAgeDays,
  });

  Future<void> crateApiCacheClearAllCache();

  Future<void> crateApiInitClearCookies();

  Future<void> crateApiCacheClearImageCache();

  Future<bool> crateApiUserClearPlayHistory();

  Future<void> crateApiCacheClearWebCache();

  Future<ApiDownloadFolder> crateApiDownloadFoldersCreateDownloadFolder({
    required String name,
  });

  Future<bool> crateApiDownloadDeleteDownload({
    required String taskId,
    required bool deleteFile,
  });

  Future<bool> crateApiDownloadFoldersDeleteDownloadFolder({
    required String folderId,
  });

  Future<bool> crateApiUserDeleteFromList({
    required String listType,
    required String videoCode,
    required String formToken,
    required String xCsrfToken,
  });

  Future<bool> crateApiUserDeletePlayHistory({required String videoId});

  Stream<ApiExportProgress> crateApiDownloadExportDownloadsToDir({
    required List<String> taskIds,
    required String destDir,
  });

  Future<String> crateApiInitExportLogsZip();

  Future<ApiSyncStatus> crateApiSyncForceUploadHistory();

  Future<List<ApiDownloadTask>> crateApiDownloadGetAllDownloads();

  Future<String> crateApiSettingsGetAppVersion();

  Future<CacheSize> crateApiCacheGetCacheSize();

  Future<CacheInfo> crateApiSettingsGetCacheSize();

  Future<ApiCloudflareChallenge?> crateApiUserGetCloudflareChallengeInfo();

  Future<List<ApiComment>> crateApiVideoGetCommentReplies({
    required String commentId,
  });

  Future<ApiUserInfo?> crateApiUserGetCurrentUser();

  Future<String> crateApiSettingsGetDataDirPath();

  Future<List<ApiDownloadFolder>> crateApiDownloadFoldersGetDownloadFolders();

  Future<List<ApiDownloadTask>> crateApiDownloadGetDownloadsByStatus({
    required String status,
  });

  Future<ApiFavoriteList> crateApiUserGetFavorites({required int page});

  Future<ApiFilterOptions> crateApiSearchGetFilterOptions();

  Future<String?> crateApiSettingsGetFlutterSettings();

  Future<ApiSearchResult> crateApiSearchGetHomeVideos({required int page});

  Future<ApiHomePage> crateApiSearchGetHomepage();

  Future<PlatformInt64?> crateApiSyncGetLastSyncTime();

  Future<String?> crateApiDownloadGetLocalVideoPath({required String videoId});

  Future<String> crateApiUserGetLoginFormToken();

  Future<ApiFavoriteList> crateApiUserGetMyList({
    required String listType,
    required int page,
  });

  Future<ApiSubscriptionsPage> crateApiUserGetMySubscriptions({
    required int page,
    String? query,
  });

  Future<ApiPlayHistoryList> crateApiUserGetPlayHistory({
    required int page,
    required int pageSize,
  });

  Future<ApiAppSettings> crateApiSettingsGetSettings();

  Future<List<ApiAuthorInfo>> crateApiUserGetSubscribedAuthors({
    required int page,
  });

  Future<String> crateApiInitGetVersion();

  Future<ApiCommentList> crateApiVideoGetVideoComments({
    required String videoId,
    required int page,
  });

  Future<ApiVideoDetail> crateApiVideoGetVideoDetail({required String videoId});

  Future<ApiPlayHistory?> crateApiUserGetVideoProgress({
    required String videoId,
  });

  Future<String> crateApiVideoGetVideoUrl({
    required String videoId,
    required String quality,
  });

  Future<ApiWebDavSettings> crateApiSyncGetWebdavSettings();

  String crateApiSimpleGreet({required String name});

  Future<void> crateApiInitInitApp({required String dataPath});

  Future<bool> crateApiSettingsInitApp({
    required String dataDir,
    required String cacheDir,
  });

  Future<void> crateApiSimpleInitApp();

  Future<bool> crateApiUserIsLoggedIn();

  Future<bool> crateApiVideoLikeComment({required String commentId});

  Future<String> crateApiCacheLoadCachedImage({required String url});

  Future<bool> crateApiUserLogin({
    required String email,
    required String password,
    required String formToken,
    required String xCsrfToken,
  });

  Future<bool> crateApiUserLogout();

  Future<bool> crateApiDownloadFoldersMoveDownloadsToFolder({
    required List<String> videoIds,
    String? folderId,
  });

  Future<bool> crateApiDownloadPauseAllDownloads();

  Future<bool> crateApiDownloadPauseDownload({required String taskId});

  Future<ApiComment> crateApiVideoPostComment({
    required String videoId,
    required String content,
    String? replyTo,
  });

  Future<List<String>> crateApiInitPrepareLogsForSharing();

  Future<bool> crateApiUserRemoveFromFavorites({
    required String videoCode,
    required String formToken,
    required String xCsrfToken,
    required String userId,
  });

  Future<bool> crateApiVideoRemoveFromFavorites({required String videoId});

  Future<bool> crateApiDownloadFoldersRenameDownloadFolder({
    required String folderId,
    required String name,
  });

  Future<void> crateApiInitReportFlutterError({
    required String message,
    String? stack,
  });

  Future<void> crateApiInitReportFlutterLog({
    required String level,
    required String message,
    String? tag,
    String? stack,
  });

  Future<bool> crateApiDownloadResumeAllDownloads();

  Future<bool> crateApiDownloadResumeDownload({required String taskId});

  Future<bool> crateApiSettingsSaveFlutterSettings({required String json});

  Future<bool> crateApiSettingsSaveSettings({required ApiAppSettings settings});

  Future<bool> crateApiSyncSaveWebdavSettings({
    required ApiWebDavSettings settings,
  });

  Future<ApiSearchResult> crateApiSearchSearch({
    required ApiSearchFilters filters,
  });

  Future<bool> crateApiUserSetCfClearance({required String cookieValue});

  Future<void> crateApiInitSetCookies({required String cookieString});

  Future<bool> crateApiUserSetCookies({
    required List<(String, String)> cookies,
  });

  Future<bool> crateApiSettingsSetDefaultQuality({required String quality});

  Future<bool> crateApiSettingsSetDownloadConcurrent({required int count});

  Future<bool> crateApiSettingsSetProxy({String? proxyUrl});

  Future<bool> crateApiSyncShouldAutoSync();

  Future<bool> crateApiUserSubscribeAuthor({
    required String artistId,
    required String userId,
    required String formToken,
    required String xCsrfToken,
  });

  Stream<ApiDownloadTask> crateApiDownloadSubscribeDownloadProgress();

  Future<ApiSyncStatus> crateApiSyncSyncHistory({required bool forceUpload});

  Future<bool> crateApiSyncTestWebdavConnection({
    required String url,
    required String username,
    required String password,
  });

  Future<bool> crateApiUserUnsubscribeAuthor({
    required String artistId,
    required String userId,
    required String formToken,
    required String xCsrfToken,
  });

  Future<bool> crateApiSyncUpdateLastSyncTime();

  Future<bool> crateApiUserUpdatePlayHistory({
    required String videoId,
    required String title,
    required String coverUrl,
    required double progress,
    required int duration,
  });

  Future<void> crateApiCacheVacuumDatabase();
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<ApiDownloadTask> crateApiDownloadAddDownload({
    required String videoId,
    required String title,
    required String coverUrl,
    required String quality,
    String? description,
    required List<String> tags,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(videoId, serializer);
          sse_encode_String(title, serializer);
          sse_encode_String(coverUrl, serializer);
          sse_encode_String(quality, serializer);
          sse_encode_opt_String(description, serializer);
          sse_encode_list_String(tags, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 1,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_download_task,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadAddDownloadConstMeta,
        argValues: [videoId, title, coverUrl, quality, description, tags],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadAddDownloadConstMeta =>
      const TaskConstMeta(
        debugName: "add_download",
        argNames: [
          "videoId",
          "title",
          "coverUrl",
          "quality",
          "description",
          "tags",
        ],
      );

  @override
  Future<bool> crateApiUserAddToFavorites({
    required String videoCode,
    required String formToken,
    required String xCsrfToken,
    required String userId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(videoCode, serializer);
          sse_encode_String(formToken, serializer);
          sse_encode_String(xCsrfToken, serializer);
          sse_encode_String(userId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 2,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserAddToFavoritesConstMeta,
        argValues: [videoCode, formToken, xCsrfToken, userId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserAddToFavoritesConstMeta => const TaskConstMeta(
    debugName: "add_to_favorites",
    argNames: ["videoCode", "formToken", "xCsrfToken", "userId"],
  );

  @override
  Future<bool> crateApiVideoAddToFavorites({required String videoId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(videoId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 3,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiVideoAddToFavoritesConstMeta,
        argValues: [videoId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiVideoAddToFavoritesConstMeta =>
      const TaskConstMeta(debugName: "add_to_favorites", argNames: ["videoId"]);

  @override
  Future<ApiAppSettings> crateApiModelsApiAppSettingsDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 4,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_app_settings,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModelsApiAppSettingsDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModelsApiAppSettingsDefaultConstMeta =>
      const TaskConstMeta(debugName: "api_app_settings_default", argNames: []);

  @override
  Future<ApiSearchFilters> crateApiModelsApiSearchFiltersDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 5,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_search_filters,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModelsApiSearchFiltersDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModelsApiSearchFiltersDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "api_search_filters_default",
        argNames: [],
      );

  @override
  Future<ApiWebDavSettings> crateApiSyncApiWebDavSettingsDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 6,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_web_dav_settings,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSyncApiWebDavSettingsDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSyncApiWebDavSettingsDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "api_web_dav_settings_default",
        argNames: [],
      );

  @override
  Future<void> crateApiCacheAutoCleanCache({
    PlatformInt64? webExpireMs,
    PlatformInt64? imageExpireMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_opt_box_autoadd_i_64(webExpireMs, serializer);
          sse_encode_opt_box_autoadd_i_64(imageExpireMs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 7,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCacheAutoCleanCacheConstMeta,
        argValues: [webExpireMs, imageExpireMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCacheAutoCleanCacheConstMeta =>
      const TaskConstMeta(
        debugName: "auto_clean_cache",
        argNames: ["webExpireMs", "imageExpireMs"],
      );

  @override
  Future<CacheSize> crateApiCacheCacheSizeDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 8,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cache_size,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCacheCacheSizeDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCacheCacheSizeDefaultConstMeta =>
      const TaskConstMeta(debugName: "cache_size_default", argNames: []);

  @override
  Future<bool> crateApiInitCheckCloudflare() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 9,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiInitCheckCloudflareConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitCheckCloudflareConstMeta =>
      const TaskConstMeta(debugName: "check_cloudflare", argNames: []);

  @override
  Future<bool> crateApiInitCheckNetwork() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 10,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiInitCheckNetworkConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitCheckNetworkConstMeta =>
      const TaskConstMeta(debugName: "check_network", argNames: []);

  @override
  Future<PlatformInt64> crateApiSyncCleanupExpiredHistory() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 11,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_i_64,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSyncCleanupExpiredHistoryConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSyncCleanupExpiredHistoryConstMeta =>
      const TaskConstMeta(debugName: "cleanup_expired_history", argNames: []);

  @override
  Future<void> crateApiInitCleanupLogs({
    required String dataPath,
    BigInt? maxTotalBytes,
    int? maxFiles,
    PlatformInt64? maxAgeDays,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(dataPath, serializer);
          sse_encode_opt_box_autoadd_u_64(maxTotalBytes, serializer);
          sse_encode_opt_box_autoadd_u_32(maxFiles, serializer);
          sse_encode_opt_box_autoadd_i_64(maxAgeDays, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 12,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiInitCleanupLogsConstMeta,
        argValues: [dataPath, maxTotalBytes, maxFiles, maxAgeDays],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitCleanupLogsConstMeta => const TaskConstMeta(
    debugName: "cleanup_logs",
    argNames: ["dataPath", "maxTotalBytes", "maxFiles", "maxAgeDays"],
  );

  @override
  Future<void> crateApiCacheClearAllCache() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 13,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCacheClearAllCacheConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCacheClearAllCacheConstMeta =>
      const TaskConstMeta(debugName: "clear_all_cache", argNames: []);

  @override
  Future<void> crateApiInitClearCookies() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 14,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiInitClearCookiesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitClearCookiesConstMeta =>
      const TaskConstMeta(debugName: "clear_cookies", argNames: []);

  @override
  Future<void> crateApiCacheClearImageCache() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 15,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCacheClearImageCacheConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCacheClearImageCacheConstMeta =>
      const TaskConstMeta(debugName: "clear_image_cache", argNames: []);

  @override
  Future<bool> crateApiUserClearPlayHistory() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 16,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserClearPlayHistoryConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserClearPlayHistoryConstMeta =>
      const TaskConstMeta(debugName: "clear_play_history", argNames: []);

  @override
  Future<void> crateApiCacheClearWebCache() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 17,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCacheClearWebCacheConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCacheClearWebCacheConstMeta =>
      const TaskConstMeta(debugName: "clear_web_cache", argNames: []);

  @override
  Future<ApiDownloadFolder> crateApiDownloadFoldersCreateDownloadFolder({
    required String name,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(name, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 18,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_download_folder,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadFoldersCreateDownloadFolderConstMeta,
        argValues: [name],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadFoldersCreateDownloadFolderConstMeta =>
      const TaskConstMeta(
        debugName: "create_download_folder",
        argNames: ["name"],
      );

  @override
  Future<bool> crateApiDownloadDeleteDownload({
    required String taskId,
    required bool deleteFile,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(taskId, serializer);
          sse_encode_bool(deleteFile, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 19,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadDeleteDownloadConstMeta,
        argValues: [taskId, deleteFile],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadDeleteDownloadConstMeta =>
      const TaskConstMeta(
        debugName: "delete_download",
        argNames: ["taskId", "deleteFile"],
      );

  @override
  Future<bool> crateApiDownloadFoldersDeleteDownloadFolder({
    required String folderId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(folderId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 20,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadFoldersDeleteDownloadFolderConstMeta,
        argValues: [folderId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadFoldersDeleteDownloadFolderConstMeta =>
      const TaskConstMeta(
        debugName: "delete_download_folder",
        argNames: ["folderId"],
      );

  @override
  Future<bool> crateApiUserDeleteFromList({
    required String listType,
    required String videoCode,
    required String formToken,
    required String xCsrfToken,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(listType, serializer);
          sse_encode_String(videoCode, serializer);
          sse_encode_String(formToken, serializer);
          sse_encode_String(xCsrfToken, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 21,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserDeleteFromListConstMeta,
        argValues: [listType, videoCode, formToken, xCsrfToken],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserDeleteFromListConstMeta => const TaskConstMeta(
    debugName: "delete_from_list",
    argNames: ["listType", "videoCode", "formToken", "xCsrfToken"],
  );

  @override
  Future<bool> crateApiUserDeletePlayHistory({required String videoId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(videoId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 22,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserDeletePlayHistoryConstMeta,
        argValues: [videoId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserDeletePlayHistoryConstMeta =>
      const TaskConstMeta(
        debugName: "delete_play_history",
        argNames: ["videoId"],
      );

  @override
  Stream<ApiExportProgress> crateApiDownloadExportDownloadsToDir({
    required List<String> taskIds,
    required String destDir,
  }) {
    final sink = RustStreamSink<ApiExportProgress>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_list_String(taskIds, serializer);
            sse_encode_String(destDir, serializer);
            sse_encode_StreamSink_api_export_progress_Sse(sink, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 23,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: null,
          ),
          constMeta: kCrateApiDownloadExportDownloadsToDirConstMeta,
          argValues: [taskIds, destDir, sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiDownloadExportDownloadsToDirConstMeta =>
      const TaskConstMeta(
        debugName: "export_downloads_to_dir",
        argNames: ["taskIds", "destDir", "sink"],
      );

  @override
  Future<String> crateApiInitExportLogsZip() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 24,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiInitExportLogsZipConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitExportLogsZipConstMeta =>
      const TaskConstMeta(debugName: "export_logs_zip", argNames: []);

  @override
  Future<ApiSyncStatus> crateApiSyncForceUploadHistory() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 25,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_sync_status,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSyncForceUploadHistoryConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSyncForceUploadHistoryConstMeta =>
      const TaskConstMeta(debugName: "force_upload_history", argNames: []);

  @override
  Future<List<ApiDownloadTask>> crateApiDownloadGetAllDownloads() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 26,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_api_download_task,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadGetAllDownloadsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadGetAllDownloadsConstMeta =>
      const TaskConstMeta(debugName: "get_all_downloads", argNames: []);

  @override
  Future<String> crateApiSettingsGetAppVersion() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 27,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSettingsGetAppVersionConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSettingsGetAppVersionConstMeta =>
      const TaskConstMeta(debugName: "get_app_version", argNames: []);

  @override
  Future<CacheSize> crateApiCacheGetCacheSize() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 28,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cache_size,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCacheGetCacheSizeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCacheGetCacheSizeConstMeta =>
      const TaskConstMeta(debugName: "get_cache_size", argNames: []);

  @override
  Future<CacheInfo> crateApiSettingsGetCacheSize() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 29,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cache_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSettingsGetCacheSizeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSettingsGetCacheSizeConstMeta =>
      const TaskConstMeta(debugName: "get_cache_size", argNames: []);

  @override
  Future<ApiCloudflareChallenge?> crateApiUserGetCloudflareChallengeInfo() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 30,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_opt_box_autoadd_api_cloudflare_challenge,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserGetCloudflareChallengeInfoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserGetCloudflareChallengeInfoConstMeta =>
      const TaskConstMeta(
        debugName: "get_cloudflare_challenge_info",
        argNames: [],
      );

  @override
  Future<List<ApiComment>> crateApiVideoGetCommentReplies({
    required String commentId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(commentId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 31,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_api_comment,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiVideoGetCommentRepliesConstMeta,
        argValues: [commentId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiVideoGetCommentRepliesConstMeta =>
      const TaskConstMeta(
        debugName: "get_comment_replies",
        argNames: ["commentId"],
      );

  @override
  Future<ApiUserInfo?> crateApiUserGetCurrentUser() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 32,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_api_user_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserGetCurrentUserConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserGetCurrentUserConstMeta =>
      const TaskConstMeta(debugName: "get_current_user", argNames: []);

  @override
  Future<String> crateApiSettingsGetDataDirPath() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 33,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSettingsGetDataDirPathConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSettingsGetDataDirPathConstMeta =>
      const TaskConstMeta(debugName: "get_data_dir_path", argNames: []);

  @override
  Future<List<ApiDownloadFolder>> crateApiDownloadFoldersGetDownloadFolders() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 34,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_api_download_folder,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadFoldersGetDownloadFoldersConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadFoldersGetDownloadFoldersConstMeta =>
      const TaskConstMeta(debugName: "get_download_folders", argNames: []);

  @override
  Future<List<ApiDownloadTask>> crateApiDownloadGetDownloadsByStatus({
    required String status,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(status, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 35,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_api_download_task,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadGetDownloadsByStatusConstMeta,
        argValues: [status],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadGetDownloadsByStatusConstMeta =>
      const TaskConstMeta(
        debugName: "get_downloads_by_status",
        argNames: ["status"],
      );

  @override
  Future<ApiFavoriteList> crateApiUserGetFavorites({required int page}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_32(page, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 36,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_favorite_list,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserGetFavoritesConstMeta,
        argValues: [page],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserGetFavoritesConstMeta =>
      const TaskConstMeta(debugName: "get_favorites", argNames: ["page"]);

  @override
  Future<ApiFilterOptions> crateApiSearchGetFilterOptions() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 37,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_filter_options,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSearchGetFilterOptionsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSearchGetFilterOptionsConstMeta =>
      const TaskConstMeta(debugName: "get_filter_options", argNames: []);

  @override
  Future<String?> crateApiSettingsGetFlutterSettings() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 38,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSettingsGetFlutterSettingsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSettingsGetFlutterSettingsConstMeta =>
      const TaskConstMeta(debugName: "get_flutter_settings", argNames: []);

  @override
  Future<ApiSearchResult> crateApiSearchGetHomeVideos({required int page}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_32(page, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 39,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_search_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSearchGetHomeVideosConstMeta,
        argValues: [page],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSearchGetHomeVideosConstMeta =>
      const TaskConstMeta(debugName: "get_home_videos", argNames: ["page"]);

  @override
  Future<ApiHomePage> crateApiSearchGetHomepage() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 40,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_home_page,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSearchGetHomepageConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSearchGetHomepageConstMeta =>
      const TaskConstMeta(debugName: "get_homepage", argNames: []);

  @override
  Future<PlatformInt64?> crateApiSyncGetLastSyncTime() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 41,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_i_64,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSyncGetLastSyncTimeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSyncGetLastSyncTimeConstMeta =>
      const TaskConstMeta(debugName: "get_last_sync_time", argNames: []);

  @override
  Future<String?> crateApiDownloadGetLocalVideoPath({required String videoId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(videoId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 42,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadGetLocalVideoPathConstMeta,
        argValues: [videoId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadGetLocalVideoPathConstMeta =>
      const TaskConstMeta(
        debugName: "get_local_video_path",
        argNames: ["videoId"],
      );

  @override
  Future<String> crateApiUserGetLoginFormToken() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 43,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserGetLoginFormTokenConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserGetLoginFormTokenConstMeta =>
      const TaskConstMeta(debugName: "get_login_form_token", argNames: []);

  @override
  Future<ApiFavoriteList> crateApiUserGetMyList({
    required String listType,
    required int page,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(listType, serializer);
          sse_encode_u_32(page, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 44,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_favorite_list,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserGetMyListConstMeta,
        argValues: [listType, page],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserGetMyListConstMeta => const TaskConstMeta(
    debugName: "get_my_list",
    argNames: ["listType", "page"],
  );

  @override
  Future<ApiSubscriptionsPage> crateApiUserGetMySubscriptions({
    required int page,
    String? query,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_32(page, serializer);
          sse_encode_opt_String(query, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 45,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_subscriptions_page,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserGetMySubscriptionsConstMeta,
        argValues: [page, query],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserGetMySubscriptionsConstMeta =>
      const TaskConstMeta(
        debugName: "get_my_subscriptions",
        argNames: ["page", "query"],
      );

  @override
  Future<ApiPlayHistoryList> crateApiUserGetPlayHistory({
    required int page,
    required int pageSize,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_32(page, serializer);
          sse_encode_u_32(pageSize, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 46,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_play_history_list,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserGetPlayHistoryConstMeta,
        argValues: [page, pageSize],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserGetPlayHistoryConstMeta => const TaskConstMeta(
    debugName: "get_play_history",
    argNames: ["page", "pageSize"],
  );

  @override
  Future<ApiAppSettings> crateApiSettingsGetSettings() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 47,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_app_settings,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSettingsGetSettingsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSettingsGetSettingsConstMeta =>
      const TaskConstMeta(debugName: "get_settings", argNames: []);

  @override
  Future<List<ApiAuthorInfo>> crateApiUserGetSubscribedAuthors({
    required int page,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_32(page, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 48,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_api_author_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserGetSubscribedAuthorsConstMeta,
        argValues: [page],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserGetSubscribedAuthorsConstMeta =>
      const TaskConstMeta(
        debugName: "get_subscribed_authors",
        argNames: ["page"],
      );

  @override
  Future<String> crateApiInitGetVersion() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 49,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiInitGetVersionConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitGetVersionConstMeta =>
      const TaskConstMeta(debugName: "get_version", argNames: []);

  @override
  Future<ApiCommentList> crateApiVideoGetVideoComments({
    required String videoId,
    required int page,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(videoId, serializer);
          sse_encode_u_32(page, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 50,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_comment_list,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiVideoGetVideoCommentsConstMeta,
        argValues: [videoId, page],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiVideoGetVideoCommentsConstMeta =>
      const TaskConstMeta(
        debugName: "get_video_comments",
        argNames: ["videoId", "page"],
      );

  @override
  Future<ApiVideoDetail> crateApiVideoGetVideoDetail({
    required String videoId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(videoId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 51,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_video_detail,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiVideoGetVideoDetailConstMeta,
        argValues: [videoId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiVideoGetVideoDetailConstMeta =>
      const TaskConstMeta(debugName: "get_video_detail", argNames: ["videoId"]);

  @override
  Future<ApiPlayHistory?> crateApiUserGetVideoProgress({
    required String videoId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(videoId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 52,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_api_play_history,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserGetVideoProgressConstMeta,
        argValues: [videoId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserGetVideoProgressConstMeta =>
      const TaskConstMeta(
        debugName: "get_video_progress",
        argNames: ["videoId"],
      );

  @override
  Future<String> crateApiVideoGetVideoUrl({
    required String videoId,
    required String quality,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(videoId, serializer);
          sse_encode_String(quality, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 53,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiVideoGetVideoUrlConstMeta,
        argValues: [videoId, quality],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiVideoGetVideoUrlConstMeta => const TaskConstMeta(
    debugName: "get_video_url",
    argNames: ["videoId", "quality"],
  );

  @override
  Future<ApiWebDavSettings> crateApiSyncGetWebdavSettings() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 54,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_web_dav_settings,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSyncGetWebdavSettingsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSyncGetWebdavSettingsConstMeta =>
      const TaskConstMeta(debugName: "get_webdav_settings", argNames: []);

  @override
  String crateApiSimpleGreet({required String name}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(name, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 55)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSimpleGreetConstMeta,
        argValues: [name],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSimpleGreetConstMeta =>
      const TaskConstMeta(debugName: "greet", argNames: ["name"]);

  @override
  Future<void> crateApiInitInitApp({required String dataPath}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(dataPath, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 56,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiInitInitAppConstMeta,
        argValues: [dataPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitInitAppConstMeta =>
      const TaskConstMeta(debugName: "init_app", argNames: ["dataPath"]);

  @override
  Future<bool> crateApiSettingsInitApp({
    required String dataDir,
    required String cacheDir,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(dataDir, serializer);
          sse_encode_String(cacheDir, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 57,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSettingsInitAppConstMeta,
        argValues: [dataDir, cacheDir],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSettingsInitAppConstMeta => const TaskConstMeta(
    debugName: "init_app",
    argNames: ["dataDir", "cacheDir"],
  );

  @override
  Future<void> crateApiSimpleInitApp() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 58,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSimpleInitAppConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSimpleInitAppConstMeta =>
      const TaskConstMeta(debugName: "init_app", argNames: []);

  @override
  Future<bool> crateApiUserIsLoggedIn() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 59,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserIsLoggedInConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserIsLoggedInConstMeta =>
      const TaskConstMeta(debugName: "is_logged_in", argNames: []);

  @override
  Future<bool> crateApiVideoLikeComment({required String commentId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(commentId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 60,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiVideoLikeCommentConstMeta,
        argValues: [commentId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiVideoLikeCommentConstMeta =>
      const TaskConstMeta(debugName: "like_comment", argNames: ["commentId"]);

  @override
  Future<String> crateApiCacheLoadCachedImage({required String url}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(url, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 61,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCacheLoadCachedImageConstMeta,
        argValues: [url],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCacheLoadCachedImageConstMeta =>
      const TaskConstMeta(debugName: "load_cached_image", argNames: ["url"]);

  @override
  Future<bool> crateApiUserLogin({
    required String email,
    required String password,
    required String formToken,
    required String xCsrfToken,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(email, serializer);
          sse_encode_String(password, serializer);
          sse_encode_String(formToken, serializer);
          sse_encode_String(xCsrfToken, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 62,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserLoginConstMeta,
        argValues: [email, password, formToken, xCsrfToken],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserLoginConstMeta => const TaskConstMeta(
    debugName: "login",
    argNames: ["email", "password", "formToken", "xCsrfToken"],
  );

  @override
  Future<bool> crateApiUserLogout() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 63,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserLogoutConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserLogoutConstMeta =>
      const TaskConstMeta(debugName: "logout", argNames: []);

  @override
  Future<bool> crateApiDownloadFoldersMoveDownloadsToFolder({
    required List<String> videoIds,
    String? folderId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_String(videoIds, serializer);
          sse_encode_opt_String(folderId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 64,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadFoldersMoveDownloadsToFolderConstMeta,
        argValues: [videoIds, folderId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadFoldersMoveDownloadsToFolderConstMeta =>
      const TaskConstMeta(
        debugName: "move_downloads_to_folder",
        argNames: ["videoIds", "folderId"],
      );

  @override
  Future<bool> crateApiDownloadPauseAllDownloads() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 65,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadPauseAllDownloadsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadPauseAllDownloadsConstMeta =>
      const TaskConstMeta(debugName: "pause_all_downloads", argNames: []);

  @override
  Future<bool> crateApiDownloadPauseDownload({required String taskId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(taskId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 66,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadPauseDownloadConstMeta,
        argValues: [taskId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadPauseDownloadConstMeta =>
      const TaskConstMeta(debugName: "pause_download", argNames: ["taskId"]);

  @override
  Future<ApiComment> crateApiVideoPostComment({
    required String videoId,
    required String content,
    String? replyTo,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(videoId, serializer);
          sse_encode_String(content, serializer);
          sse_encode_opt_String(replyTo, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 67,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_comment,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiVideoPostCommentConstMeta,
        argValues: [videoId, content, replyTo],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiVideoPostCommentConstMeta => const TaskConstMeta(
    debugName: "post_comment",
    argNames: ["videoId", "content", "replyTo"],
  );

  @override
  Future<List<String>> crateApiInitPrepareLogsForSharing() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 68,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiInitPrepareLogsForSharingConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitPrepareLogsForSharingConstMeta =>
      const TaskConstMeta(debugName: "prepare_logs_for_sharing", argNames: []);

  @override
  Future<bool> crateApiUserRemoveFromFavorites({
    required String videoCode,
    required String formToken,
    required String xCsrfToken,
    required String userId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(videoCode, serializer);
          sse_encode_String(formToken, serializer);
          sse_encode_String(xCsrfToken, serializer);
          sse_encode_String(userId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 69,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserRemoveFromFavoritesConstMeta,
        argValues: [videoCode, formToken, xCsrfToken, userId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserRemoveFromFavoritesConstMeta =>
      const TaskConstMeta(
        debugName: "remove_from_favorites",
        argNames: ["videoCode", "formToken", "xCsrfToken", "userId"],
      );

  @override
  Future<bool> crateApiVideoRemoveFromFavorites({required String videoId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(videoId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 70,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiVideoRemoveFromFavoritesConstMeta,
        argValues: [videoId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiVideoRemoveFromFavoritesConstMeta =>
      const TaskConstMeta(
        debugName: "remove_from_favorites",
        argNames: ["videoId"],
      );

  @override
  Future<bool> crateApiDownloadFoldersRenameDownloadFolder({
    required String folderId,
    required String name,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(folderId, serializer);
          sse_encode_String(name, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 71,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadFoldersRenameDownloadFolderConstMeta,
        argValues: [folderId, name],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadFoldersRenameDownloadFolderConstMeta =>
      const TaskConstMeta(
        debugName: "rename_download_folder",
        argNames: ["folderId", "name"],
      );

  @override
  Future<void> crateApiInitReportFlutterError({
    required String message,
    String? stack,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(message, serializer);
          sse_encode_opt_String(stack, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 72,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiInitReportFlutterErrorConstMeta,
        argValues: [message, stack],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitReportFlutterErrorConstMeta =>
      const TaskConstMeta(
        debugName: "report_flutter_error",
        argNames: ["message", "stack"],
      );

  @override
  Future<void> crateApiInitReportFlutterLog({
    required String level,
    required String message,
    String? tag,
    String? stack,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(level, serializer);
          sse_encode_String(message, serializer);
          sse_encode_opt_String(tag, serializer);
          sse_encode_opt_String(stack, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 73,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiInitReportFlutterLogConstMeta,
        argValues: [level, message, tag, stack],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitReportFlutterLogConstMeta =>
      const TaskConstMeta(
        debugName: "report_flutter_log",
        argNames: ["level", "message", "tag", "stack"],
      );

  @override
  Future<bool> crateApiDownloadResumeAllDownloads() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 74,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadResumeAllDownloadsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadResumeAllDownloadsConstMeta =>
      const TaskConstMeta(debugName: "resume_all_downloads", argNames: []);

  @override
  Future<bool> crateApiDownloadResumeDownload({required String taskId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(taskId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 75,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloadResumeDownloadConstMeta,
        argValues: [taskId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloadResumeDownloadConstMeta =>
      const TaskConstMeta(debugName: "resume_download", argNames: ["taskId"]);

  @override
  Future<bool> crateApiSettingsSaveFlutterSettings({required String json}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(json, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 76,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSettingsSaveFlutterSettingsConstMeta,
        argValues: [json],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSettingsSaveFlutterSettingsConstMeta =>
      const TaskConstMeta(
        debugName: "save_flutter_settings",
        argNames: ["json"],
      );

  @override
  Future<bool> crateApiSettingsSaveSettings({
    required ApiAppSettings settings,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_api_app_settings(settings, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 77,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSettingsSaveSettingsConstMeta,
        argValues: [settings],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSettingsSaveSettingsConstMeta =>
      const TaskConstMeta(debugName: "save_settings", argNames: ["settings"]);

  @override
  Future<bool> crateApiSyncSaveWebdavSettings({
    required ApiWebDavSettings settings,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_api_web_dav_settings(settings, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 78,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSyncSaveWebdavSettingsConstMeta,
        argValues: [settings],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSyncSaveWebdavSettingsConstMeta =>
      const TaskConstMeta(
        debugName: "save_webdav_settings",
        argNames: ["settings"],
      );

  @override
  Future<ApiSearchResult> crateApiSearchSearch({
    required ApiSearchFilters filters,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_api_search_filters(filters, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 79,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_search_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSearchSearchConstMeta,
        argValues: [filters],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSearchSearchConstMeta =>
      const TaskConstMeta(debugName: "search", argNames: ["filters"]);

  @override
  Future<bool> crateApiUserSetCfClearance({required String cookieValue}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(cookieValue, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 80,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserSetCfClearanceConstMeta,
        argValues: [cookieValue],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserSetCfClearanceConstMeta => const TaskConstMeta(
    debugName: "set_cf_clearance",
    argNames: ["cookieValue"],
  );

  @override
  Future<void> crateApiInitSetCookies({required String cookieString}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(cookieString, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 81,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiInitSetCookiesConstMeta,
        argValues: [cookieString],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitSetCookiesConstMeta =>
      const TaskConstMeta(debugName: "set_cookies", argNames: ["cookieString"]);

  @override
  Future<bool> crateApiUserSetCookies({
    required List<(String, String)> cookies,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_record_string_string(cookies, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 82,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserSetCookiesConstMeta,
        argValues: [cookies],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserSetCookiesConstMeta =>
      const TaskConstMeta(debugName: "set_cookies", argNames: ["cookies"]);

  @override
  Future<bool> crateApiSettingsSetDefaultQuality({required String quality}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(quality, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 83,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSettingsSetDefaultQualityConstMeta,
        argValues: [quality],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSettingsSetDefaultQualityConstMeta =>
      const TaskConstMeta(
        debugName: "set_default_quality",
        argNames: ["quality"],
      );

  @override
  Future<bool> crateApiSettingsSetDownloadConcurrent({required int count}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_32(count, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 84,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSettingsSetDownloadConcurrentConstMeta,
        argValues: [count],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSettingsSetDownloadConcurrentConstMeta =>
      const TaskConstMeta(
        debugName: "set_download_concurrent",
        argNames: ["count"],
      );

  @override
  Future<bool> crateApiSettingsSetProxy({String? proxyUrl}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_opt_String(proxyUrl, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 85,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSettingsSetProxyConstMeta,
        argValues: [proxyUrl],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSettingsSetProxyConstMeta =>
      const TaskConstMeta(debugName: "set_proxy", argNames: ["proxyUrl"]);

  @override
  Future<bool> crateApiSyncShouldAutoSync() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 86,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSyncShouldAutoSyncConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSyncShouldAutoSyncConstMeta =>
      const TaskConstMeta(debugName: "should_auto_sync", argNames: []);

  @override
  Future<bool> crateApiUserSubscribeAuthor({
    required String artistId,
    required String userId,
    required String formToken,
    required String xCsrfToken,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(artistId, serializer);
          sse_encode_String(userId, serializer);
          sse_encode_String(formToken, serializer);
          sse_encode_String(xCsrfToken, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 87,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserSubscribeAuthorConstMeta,
        argValues: [artistId, userId, formToken, xCsrfToken],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserSubscribeAuthorConstMeta =>
      const TaskConstMeta(
        debugName: "subscribe_author",
        argNames: ["artistId", "userId", "formToken", "xCsrfToken"],
      );

  @override
  Stream<ApiDownloadTask> crateApiDownloadSubscribeDownloadProgress() {
    final sink = RustStreamSink<ApiDownloadTask>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_api_download_task_Sse(sink, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 88,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: null,
          ),
          constMeta: kCrateApiDownloadSubscribeDownloadProgressConstMeta,
          argValues: [sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiDownloadSubscribeDownloadProgressConstMeta =>
      const TaskConstMeta(
        debugName: "subscribe_download_progress",
        argNames: ["sink"],
      );

  @override
  Future<ApiSyncStatus> crateApiSyncSyncHistory({required bool forceUpload}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_bool(forceUpload, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 89,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_sync_status,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSyncSyncHistoryConstMeta,
        argValues: [forceUpload],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSyncSyncHistoryConstMeta =>
      const TaskConstMeta(debugName: "sync_history", argNames: ["forceUpload"]);

  @override
  Future<bool> crateApiSyncTestWebdavConnection({
    required String url,
    required String username,
    required String password,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(url, serializer);
          sse_encode_String(username, serializer);
          sse_encode_String(password, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 90,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSyncTestWebdavConnectionConstMeta,
        argValues: [url, username, password],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSyncTestWebdavConnectionConstMeta =>
      const TaskConstMeta(
        debugName: "test_webdav_connection",
        argNames: ["url", "username", "password"],
      );

  @override
  Future<bool> crateApiUserUnsubscribeAuthor({
    required String artistId,
    required String userId,
    required String formToken,
    required String xCsrfToken,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(artistId, serializer);
          sse_encode_String(userId, serializer);
          sse_encode_String(formToken, serializer);
          sse_encode_String(xCsrfToken, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 91,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserUnsubscribeAuthorConstMeta,
        argValues: [artistId, userId, formToken, xCsrfToken],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserUnsubscribeAuthorConstMeta =>
      const TaskConstMeta(
        debugName: "unsubscribe_author",
        argNames: ["artistId", "userId", "formToken", "xCsrfToken"],
      );

  @override
  Future<bool> crateApiSyncUpdateLastSyncTime() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 92,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSyncUpdateLastSyncTimeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSyncUpdateLastSyncTimeConstMeta =>
      const TaskConstMeta(debugName: "update_last_sync_time", argNames: []);

  @override
  Future<bool> crateApiUserUpdatePlayHistory({
    required String videoId,
    required String title,
    required String coverUrl,
    required double progress,
    required int duration,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(videoId, serializer);
          sse_encode_String(title, serializer);
          sse_encode_String(coverUrl, serializer);
          sse_encode_f_32(progress, serializer);
          sse_encode_u_32(duration, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 93,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUserUpdatePlayHistoryConstMeta,
        argValues: [videoId, title, coverUrl, progress, duration],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUserUpdatePlayHistoryConstMeta =>
      const TaskConstMeta(
        debugName: "update_play_history",
        argNames: ["videoId", "title", "coverUrl", "progress", "duration"],
      );

  @override
  Future<void> crateApiCacheVacuumDatabase() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 94,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCacheVacuumDatabaseConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCacheVacuumDatabaseConstMeta =>
      const TaskConstMeta(debugName: "vacuum_database", argNames: []);

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  RustStreamSink<ApiDownloadTask> dco_decode_StreamSink_api_download_task_Sse(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<ApiExportProgress>
  dco_decode_StreamSink_api_export_progress_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  ApiAppSettings dco_decode_api_app_settings(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ApiAppSettings(
      defaultQuality: dco_decode_String(arr[0]),
      downloadConcurrent: dco_decode_u_32(arr[1]),
      proxyUrl: dco_decode_opt_String(arr[2]),
      themeMode: dco_decode_String(arr[3]),
      language: dco_decode_String(arr[4]),
    );
  }

  @protected
  ApiAuthorInfo dco_decode_api_author_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ApiAuthorInfo(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      avatarUrl: dco_decode_opt_String(arr[2]),
      isSubscribed: dco_decode_bool(arr[3]),
    );
  }

  @protected
  ApiBanner dco_decode_api_banner(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ApiBanner(
      title: dco_decode_String(arr[0]),
      description: dco_decode_opt_String(arr[1]),
      picUrl: dco_decode_String(arr[2]),
      videoCode: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  ApiCloudflareChallenge dco_decode_api_cloudflare_challenge(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ApiCloudflareChallenge(
      url: dco_decode_String(arr[0]),
      userAgent: dco_decode_String(arr[1]),
    );
  }

  @protected
  ApiComment dco_decode_api_comment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return ApiComment(
      id: dco_decode_String(arr[0]),
      userName: dco_decode_String(arr[1]),
      userAvatar: dco_decode_opt_String(arr[2]),
      content: dco_decode_String(arr[3]),
      time: dco_decode_String(arr[4]),
      likes: dco_decode_u_32(arr[5]),
      dislikes: dco_decode_u_32(arr[6]),
      replies: dco_decode_list_api_comment(arr[7]),
      hasMoreReplies: dco_decode_bool(arr[8]),
    );
  }

  @protected
  ApiCommentList dco_decode_api_comment_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ApiCommentList(
      comments: dco_decode_list_api_comment(arr[0]),
      total: dco_decode_u_32(arr[1]),
      page: dco_decode_u_32(arr[2]),
      hasNext: dco_decode_bool(arr[3]),
    );
  }

  @protected
  ApiDownloadFolder dco_decode_api_download_folder(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ApiDownloadFolder(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      createdAt: dco_decode_i_64(arr[2]),
    );
  }

  @protected
  ApiDownloadStatus dco_decode_api_download_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ApiDownloadStatus_Pending();
      case 1:
        return ApiDownloadStatus_Downloading();
      case 2:
        return ApiDownloadStatus_Paused();
      case 3:
        return ApiDownloadStatus_Completed();
      case 4:
        return ApiDownloadStatus_Failed(error: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ApiDownloadTask dco_decode_api_download_task(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 20)
      throw Exception('unexpected arr length: expect 20 but see ${arr.length}');
    return ApiDownloadTask(
      id: dco_decode_String(arr[0]),
      videoId: dco_decode_String(arr[1]),
      title: dco_decode_String(arr[2]),
      coverUrl: dco_decode_String(arr[3]),
      coverPath: dco_decode_opt_String(arr[4]),
      authorId: dco_decode_opt_String(arr[5]),
      authorName: dco_decode_opt_String(arr[6]),
      authorAvatarUrl: dco_decode_opt_String(arr[7]),
      authorAvatarPath: dco_decode_opt_String(arr[8]),
      quality: dco_decode_String(arr[9]),
      description: dco_decode_opt_String(arr[10]),
      tags: dco_decode_list_String(arr[11]),
      status: dco_decode_api_download_status(arr[12]),
      progress: dco_decode_f_32(arr[13]),
      downloadedBytes: dco_decode_u_64(arr[14]),
      totalBytes: dco_decode_u_64(arr[15]),
      speed: dco_decode_u_64(arr[16]),
      createdAt: dco_decode_i_64(arr[17]),
      filePath: dco_decode_opt_String(arr[18]),
      folderId: dco_decode_opt_String(arr[19]),
    );
  }

  @protected
  ApiExportProgress dco_decode_api_export_progress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return ApiExportProgress(
      totalFiles: dco_decode_u_32(arr[0]),
      doneFiles: dco_decode_u_32(arr[1]),
      currentFile: dco_decode_opt_String(arr[2]),
      currentBytes: dco_decode_u_64(arr[3]),
      currentTotalBytes: dco_decode_u_64(arr[4]),
      done: dco_decode_bool(arr[5]),
      error: dco_decode_opt_String(arr[6]),
    );
  }

  @protected
  ApiFavoriteList dco_decode_api_favorite_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ApiFavoriteList(
      videos: dco_decode_list_api_video_card(arr[0]),
      total: dco_decode_u_32(arr[1]),
      page: dco_decode_u_32(arr[2]),
      hasNext: dco_decode_bool(arr[3]),
    );
  }

  @protected
  ApiFilterOption dco_decode_api_filter_option(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ApiFilterOption(
      value: dco_decode_String(arr[0]),
      label: dco_decode_String(arr[1]),
    );
  }

  @protected
  ApiFilterOptions dco_decode_api_filter_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ApiFilterOptions(
      genres: dco_decode_list_api_filter_option(arr[0]),
      tags: dco_decode_list_api_tag_group(arr[1]),
      sorts: dco_decode_list_api_filter_option(arr[2]),
      years: dco_decode_list_api_filter_option(arr[3]),
      durations: dco_decode_list_api_filter_option(arr[4]),
    );
  }

  @protected
  ApiHomePage dco_decode_api_home_page(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return ApiHomePage(
      formToken: dco_decode_opt_String(arr[0]),
      avatarUrl: dco_decode_opt_String(arr[1]),
      username: dco_decode_opt_String(arr[2]),
      banner: dco_decode_opt_box_autoadd_api_banner(arr[3]),
      latestRelease: dco_decode_list_api_video_card(arr[4]),
      latestUpload: dco_decode_list_api_video_card(arr[5]),
      sections: dco_decode_list_api_home_section(arr[6]),
    );
  }

  @protected
  ApiHomeSection dco_decode_api_home_section(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ApiHomeSection(
      name: dco_decode_String(arr[0]),
      videos: dco_decode_list_api_video_card(arr[1]),
    );
  }

  @protected
  ApiMyListInfo dco_decode_api_my_list_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ApiMyListInfo(
      isWatchLater: dco_decode_bool(arr[0]),
      items: dco_decode_list_api_my_list_item(arr[1]),
    );
  }

  @protected
  ApiMyListItem dco_decode_api_my_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ApiMyListItem(
      code: dco_decode_String(arr[0]),
      title: dco_decode_String(arr[1]),
      isSelected: dco_decode_bool(arr[2]),
    );
  }

  @protected
  ApiPlayHistory dco_decode_api_play_history(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ApiPlayHistory(
      videoId: dco_decode_String(arr[0]),
      title: dco_decode_String(arr[1]),
      coverUrl: dco_decode_String(arr[2]),
      progress: dco_decode_f_32(arr[3]),
      duration: dco_decode_u_32(arr[4]),
      lastPlayedAt: dco_decode_i_64(arr[5]),
    );
  }

  @protected
  ApiPlayHistoryList dco_decode_api_play_history_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ApiPlayHistoryList(
      items: dco_decode_list_api_play_history(arr[0]),
      total: dco_decode_u_32(arr[1]),
      page: dco_decode_u_32(arr[2]),
      hasNext: dco_decode_bool(arr[3]),
    );
  }

  @protected
  ApiPlaylistInfo dco_decode_api_playlist_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ApiPlaylistInfo(
      name: dco_decode_opt_String(arr[0]),
      videos: dco_decode_list_api_video_card(arr[1]),
    );
  }

  @protected
  ApiSearchFilters dco_decode_api_search_filters(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return ApiSearchFilters(
      query: dco_decode_opt_String(arr[0]),
      genre: dco_decode_opt_String(arr[1]),
      tags: dco_decode_list_String(arr[2]),
      broadMatch: dco_decode_bool(arr[3]),
      sort: dco_decode_opt_String(arr[4]),
      year: dco_decode_opt_String(arr[5]),
      month: dco_decode_opt_String(arr[6]),
      date: dco_decode_opt_String(arr[7]),
      duration: dco_decode_opt_String(arr[8]),
      page: dco_decode_u_32(arr[9]),
    );
  }

  @protected
  ApiSearchResult dco_decode_api_search_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ApiSearchResult(
      videos: dco_decode_list_api_video_card(arr[0]),
      total: dco_decode_u_32(arr[1]),
      page: dco_decode_u_32(arr[2]),
      hasNext: dco_decode_bool(arr[3]),
    );
  }

  @protected
  ApiSeriesInfo dco_decode_api_series_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ApiSeriesInfo(
      id: dco_decode_String(arr[0]),
      title: dco_decode_String(arr[1]),
      videos: dco_decode_list_api_series_video(arr[2]),
      currentIndex: dco_decode_u_32(arr[3]),
    );
  }

  @protected
  ApiSeriesVideo dco_decode_api_series_video(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ApiSeriesVideo(
      id: dco_decode_String(arr[0]),
      title: dco_decode_String(arr[1]),
      coverUrl: dco_decode_String(arr[2]),
      episode: dco_decode_String(arr[3]),
    );
  }

  @protected
  ApiSubscriptionsPage dco_decode_api_subscriptions_page(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ApiSubscriptionsPage(
      authors: dco_decode_list_api_author_info(arr[0]),
      videos: dco_decode_list_api_video_card(arr[1]),
      page: dco_decode_u_32(arr[2]),
      hasNext: dco_decode_bool(arr[3]),
    );
  }

  @protected
  ApiSyncStatus dco_decode_api_sync_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ApiSyncStatus_Success(
          mergedCount: dco_decode_i_32(raw[1]),
          uploaded: dco_decode_bool(raw[2]),
        );
      case 1:
        return ApiSyncStatus_DecryptionFailed();
      case 2:
        return ApiSyncStatus_NeedNewKey();
      case 3:
        return ApiSyncStatus_NetworkError(message: dco_decode_String(raw[1]));
      case 4:
        return ApiSyncStatus_NotConfigured();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ApiTagGroup dco_decode_api_tag_group(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ApiTagGroup(
      name: dco_decode_String(arr[0]),
      tags: dco_decode_list_api_filter_option(arr[1]),
    );
  }

  @protected
  ApiUserInfo dco_decode_api_user_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ApiUserInfo(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      avatarUrl: dco_decode_opt_String(arr[2]),
      isLoggedIn: dco_decode_bool(arr[3]),
    );
  }

  @protected
  ApiVideoCard dco_decode_api_video_card(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return ApiVideoCard(
      id: dco_decode_String(arr[0]),
      title: dco_decode_String(arr[1]),
      coverUrl: dco_decode_String(arr[2]),
      duration: dco_decode_opt_String(arr[3]),
      views: dco_decode_opt_String(arr[4]),
      uploadDate: dco_decode_opt_String(arr[5]),
      authorName: dco_decode_opt_String(arr[6]),
      tags: dco_decode_list_String(arr[7]),
    );
  }

  @protected
  ApiVideoDetail dco_decode_api_video_detail(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 23)
      throw Exception('unexpected arr length: expect 23 but see ${arr.length}');
    return ApiVideoDetail(
      id: dco_decode_String(arr[0]),
      title: dco_decode_String(arr[1]),
      chineseTitle: dco_decode_opt_String(arr[2]),
      coverUrl: dco_decode_String(arr[3]),
      description: dco_decode_opt_String(arr[4]),
      duration: dco_decode_opt_String(arr[5]),
      views: dco_decode_opt_String(arr[6]),
      likePercent: dco_decode_opt_box_autoadd_u_32(arr[7]),
      dislikePercent: dco_decode_opt_box_autoadd_u_32(arr[8]),
      likesCount: dco_decode_opt_box_autoadd_u_32(arr[9]),
      dislikesCount: dco_decode_opt_box_autoadd_u_32(arr[10]),
      uploadDate: dco_decode_opt_String(arr[11]),
      author: dco_decode_opt_box_autoadd_api_author_info(arr[12]),
      tags: dco_decode_list_String(arr[13]),
      qualities: dco_decode_list_api_video_quality(arr[14]),
      series: dco_decode_opt_box_autoadd_api_series_info(arr[15]),
      relatedVideos: dco_decode_list_api_video_card(arr[16]),
      formToken: dco_decode_opt_String(arr[17]),
      currentUserId: dco_decode_opt_String(arr[18]),
      isFav: dco_decode_bool(arr[19]),
      favTimes: dco_decode_opt_box_autoadd_i_32(arr[20]),
      playlist: dco_decode_opt_box_autoadd_api_playlist_info(arr[21]),
      myList: dco_decode_opt_box_autoadd_api_my_list_info(arr[22]),
    );
  }

  @protected
  ApiVideoQuality dco_decode_api_video_quality(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ApiVideoQuality(
      quality: dco_decode_String(arr[0]),
      url: dco_decode_String(arr[1]),
    );
  }

  @protected
  ApiWebDavSettings dco_decode_api_web_dav_settings(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ApiWebDavSettings(
      url: dco_decode_String(arr[0]),
      username: dco_decode_String(arr[1]),
      password: dco_decode_String(arr[2]),
      encryptionKey: dco_decode_String(arr[3]),
      autoSyncOnStart: dco_decode_bool(arr[4]),
      autoSyncInterval: dco_decode_i_32(arr[5]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  ApiAppSettings dco_decode_box_autoadd_api_app_settings(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_app_settings(raw);
  }

  @protected
  ApiAuthorInfo dco_decode_box_autoadd_api_author_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_author_info(raw);
  }

  @protected
  ApiBanner dco_decode_box_autoadd_api_banner(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_banner(raw);
  }

  @protected
  ApiCloudflareChallenge dco_decode_box_autoadd_api_cloudflare_challenge(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_cloudflare_challenge(raw);
  }

  @protected
  ApiMyListInfo dco_decode_box_autoadd_api_my_list_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_my_list_info(raw);
  }

  @protected
  ApiPlayHistory dco_decode_box_autoadd_api_play_history(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_play_history(raw);
  }

  @protected
  ApiPlaylistInfo dco_decode_box_autoadd_api_playlist_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_playlist_info(raw);
  }

  @protected
  ApiSearchFilters dco_decode_box_autoadd_api_search_filters(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_search_filters(raw);
  }

  @protected
  ApiSeriesInfo dco_decode_box_autoadd_api_series_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_series_info(raw);
  }

  @protected
  ApiUserInfo dco_decode_box_autoadd_api_user_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_user_info(raw);
  }

  @protected
  ApiWebDavSettings dco_decode_box_autoadd_api_web_dav_settings(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_web_dav_settings(raw);
  }

  @protected
  int dco_decode_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_i_64(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  CacheInfo dco_decode_cache_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return CacheInfo(
      coverCacheSize: dco_decode_u_64(arr[0]),
      videoCacheSize: dco_decode_u_64(arr[1]),
      totalSize: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  CacheSize dco_decode_cache_size(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return CacheSize(
      imageCacheBytes: dco_decode_u_64(arr[0]),
      imageCacheCount: dco_decode_u_64(arr[1]),
      webCacheCount: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<ApiAuthorInfo> dco_decode_list_api_author_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_author_info).toList();
  }

  @protected
  List<ApiComment> dco_decode_list_api_comment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_comment).toList();
  }

  @protected
  List<ApiDownloadFolder> dco_decode_list_api_download_folder(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_download_folder).toList();
  }

  @protected
  List<ApiDownloadTask> dco_decode_list_api_download_task(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_download_task).toList();
  }

  @protected
  List<ApiFilterOption> dco_decode_list_api_filter_option(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_filter_option).toList();
  }

  @protected
  List<ApiHomeSection> dco_decode_list_api_home_section(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_home_section).toList();
  }

  @protected
  List<ApiMyListItem> dco_decode_list_api_my_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_my_list_item).toList();
  }

  @protected
  List<ApiPlayHistory> dco_decode_list_api_play_history(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_play_history).toList();
  }

  @protected
  List<ApiSeriesVideo> dco_decode_list_api_series_video(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_series_video).toList();
  }

  @protected
  List<ApiTagGroup> dco_decode_list_api_tag_group(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_tag_group).toList();
  }

  @protected
  List<ApiVideoCard> dco_decode_list_api_video_card(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_video_card).toList();
  }

  @protected
  List<ApiVideoQuality> dco_decode_list_api_video_quality(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_video_quality).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  ApiAuthorInfo? dco_decode_opt_box_autoadd_api_author_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_api_author_info(raw);
  }

  @protected
  ApiBanner? dco_decode_opt_box_autoadd_api_banner(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_api_banner(raw);
  }

  @protected
  ApiCloudflareChallenge? dco_decode_opt_box_autoadd_api_cloudflare_challenge(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_api_cloudflare_challenge(raw);
  }

  @protected
  ApiMyListInfo? dco_decode_opt_box_autoadd_api_my_list_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_api_my_list_info(raw);
  }

  @protected
  ApiPlayHistory? dco_decode_opt_box_autoadd_api_play_history(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_api_play_history(raw);
  }

  @protected
  ApiPlaylistInfo? dco_decode_opt_box_autoadd_api_playlist_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_api_playlist_info(raw);
  }

  @protected
  ApiSeriesInfo? dco_decode_opt_box_autoadd_api_series_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_api_series_info(raw);
  }

  @protected
  ApiUserInfo? dco_decode_opt_box_autoadd_api_user_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_api_user_info(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_32(raw);
  }

  @protected
  PlatformInt64? dco_decode_opt_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_String(arr[0]), dco_decode_String(arr[1]));
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  RustStreamSink<ApiDownloadTask> sse_decode_StreamSink_api_download_task_Sse(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<ApiExportProgress>
  sse_decode_StreamSink_api_export_progress_Sse(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  ApiAppSettings sse_decode_api_app_settings(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_defaultQuality = sse_decode_String(deserializer);
    var var_downloadConcurrent = sse_decode_u_32(deserializer);
    var var_proxyUrl = sse_decode_opt_String(deserializer);
    var var_themeMode = sse_decode_String(deserializer);
    var var_language = sse_decode_String(deserializer);
    return ApiAppSettings(
      defaultQuality: var_defaultQuality,
      downloadConcurrent: var_downloadConcurrent,
      proxyUrl: var_proxyUrl,
      themeMode: var_themeMode,
      language: var_language,
    );
  }

  @protected
  ApiAuthorInfo sse_decode_api_author_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_avatarUrl = sse_decode_opt_String(deserializer);
    var var_isSubscribed = sse_decode_bool(deserializer);
    return ApiAuthorInfo(
      id: var_id,
      name: var_name,
      avatarUrl: var_avatarUrl,
      isSubscribed: var_isSubscribed,
    );
  }

  @protected
  ApiBanner sse_decode_api_banner(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_title = sse_decode_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_picUrl = sse_decode_String(deserializer);
    var var_videoCode = sse_decode_opt_String(deserializer);
    return ApiBanner(
      title: var_title,
      description: var_description,
      picUrl: var_picUrl,
      videoCode: var_videoCode,
    );
  }

  @protected
  ApiCloudflareChallenge sse_decode_api_cloudflare_challenge(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_userAgent = sse_decode_String(deserializer);
    return ApiCloudflareChallenge(url: var_url, userAgent: var_userAgent);
  }

  @protected
  ApiComment sse_decode_api_comment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_userName = sse_decode_String(deserializer);
    var var_userAvatar = sse_decode_opt_String(deserializer);
    var var_content = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    var var_likes = sse_decode_u_32(deserializer);
    var var_dislikes = sse_decode_u_32(deserializer);
    var var_replies = sse_decode_list_api_comment(deserializer);
    var var_hasMoreReplies = sse_decode_bool(deserializer);
    return ApiComment(
      id: var_id,
      userName: var_userName,
      userAvatar: var_userAvatar,
      content: var_content,
      time: var_time,
      likes: var_likes,
      dislikes: var_dislikes,
      replies: var_replies,
      hasMoreReplies: var_hasMoreReplies,
    );
  }

  @protected
  ApiCommentList sse_decode_api_comment_list(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_comments = sse_decode_list_api_comment(deserializer);
    var var_total = sse_decode_u_32(deserializer);
    var var_page = sse_decode_u_32(deserializer);
    var var_hasNext = sse_decode_bool(deserializer);
    return ApiCommentList(
      comments: var_comments,
      total: var_total,
      page: var_page,
      hasNext: var_hasNext,
    );
  }

  @protected
  ApiDownloadFolder sse_decode_api_download_folder(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_createdAt = sse_decode_i_64(deserializer);
    return ApiDownloadFolder(
      id: var_id,
      name: var_name,
      createdAt: var_createdAt,
    );
  }

  @protected
  ApiDownloadStatus sse_decode_api_download_status(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return ApiDownloadStatus_Pending();
      case 1:
        return ApiDownloadStatus_Downloading();
      case 2:
        return ApiDownloadStatus_Paused();
      case 3:
        return ApiDownloadStatus_Completed();
      case 4:
        var var_error = sse_decode_String(deserializer);
        return ApiDownloadStatus_Failed(error: var_error);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ApiDownloadTask sse_decode_api_download_task(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_videoId = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_coverUrl = sse_decode_String(deserializer);
    var var_coverPath = sse_decode_opt_String(deserializer);
    var var_authorId = sse_decode_opt_String(deserializer);
    var var_authorName = sse_decode_opt_String(deserializer);
    var var_authorAvatarUrl = sse_decode_opt_String(deserializer);
    var var_authorAvatarPath = sse_decode_opt_String(deserializer);
    var var_quality = sse_decode_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_tags = sse_decode_list_String(deserializer);
    var var_status = sse_decode_api_download_status(deserializer);
    var var_progress = sse_decode_f_32(deserializer);
    var var_downloadedBytes = sse_decode_u_64(deserializer);
    var var_totalBytes = sse_decode_u_64(deserializer);
    var var_speed = sse_decode_u_64(deserializer);
    var var_createdAt = sse_decode_i_64(deserializer);
    var var_filePath = sse_decode_opt_String(deserializer);
    var var_folderId = sse_decode_opt_String(deserializer);
    return ApiDownloadTask(
      id: var_id,
      videoId: var_videoId,
      title: var_title,
      coverUrl: var_coverUrl,
      coverPath: var_coverPath,
      authorId: var_authorId,
      authorName: var_authorName,
      authorAvatarUrl: var_authorAvatarUrl,
      authorAvatarPath: var_authorAvatarPath,
      quality: var_quality,
      description: var_description,
      tags: var_tags,
      status: var_status,
      progress: var_progress,
      downloadedBytes: var_downloadedBytes,
      totalBytes: var_totalBytes,
      speed: var_speed,
      createdAt: var_createdAt,
      filePath: var_filePath,
      folderId: var_folderId,
    );
  }

  @protected
  ApiExportProgress sse_decode_api_export_progress(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_totalFiles = sse_decode_u_32(deserializer);
    var var_doneFiles = sse_decode_u_32(deserializer);
    var var_currentFile = sse_decode_opt_String(deserializer);
    var var_currentBytes = sse_decode_u_64(deserializer);
    var var_currentTotalBytes = sse_decode_u_64(deserializer);
    var var_done = sse_decode_bool(deserializer);
    var var_error = sse_decode_opt_String(deserializer);
    return ApiExportProgress(
      totalFiles: var_totalFiles,
      doneFiles: var_doneFiles,
      currentFile: var_currentFile,
      currentBytes: var_currentBytes,
      currentTotalBytes: var_currentTotalBytes,
      done: var_done,
      error: var_error,
    );
  }

  @protected
  ApiFavoriteList sse_decode_api_favorite_list(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_videos = sse_decode_list_api_video_card(deserializer);
    var var_total = sse_decode_u_32(deserializer);
    var var_page = sse_decode_u_32(deserializer);
    var var_hasNext = sse_decode_bool(deserializer);
    return ApiFavoriteList(
      videos: var_videos,
      total: var_total,
      page: var_page,
      hasNext: var_hasNext,
    );
  }

  @protected
  ApiFilterOption sse_decode_api_filter_option(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_String(deserializer);
    var var_label = sse_decode_String(deserializer);
    return ApiFilterOption(value: var_value, label: var_label);
  }

  @protected
  ApiFilterOptions sse_decode_api_filter_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_genres = sse_decode_list_api_filter_option(deserializer);
    var var_tags = sse_decode_list_api_tag_group(deserializer);
    var var_sorts = sse_decode_list_api_filter_option(deserializer);
    var var_years = sse_decode_list_api_filter_option(deserializer);
    var var_durations = sse_decode_list_api_filter_option(deserializer);
    return ApiFilterOptions(
      genres: var_genres,
      tags: var_tags,
      sorts: var_sorts,
      years: var_years,
      durations: var_durations,
    );
  }

  @protected
  ApiHomePage sse_decode_api_home_page(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_formToken = sse_decode_opt_String(deserializer);
    var var_avatarUrl = sse_decode_opt_String(deserializer);
    var var_username = sse_decode_opt_String(deserializer);
    var var_banner = sse_decode_opt_box_autoadd_api_banner(deserializer);
    var var_latestRelease = sse_decode_list_api_video_card(deserializer);
    var var_latestUpload = sse_decode_list_api_video_card(deserializer);
    var var_sections = sse_decode_list_api_home_section(deserializer);
    return ApiHomePage(
      formToken: var_formToken,
      avatarUrl: var_avatarUrl,
      username: var_username,
      banner: var_banner,
      latestRelease: var_latestRelease,
      latestUpload: var_latestUpload,
      sections: var_sections,
    );
  }

  @protected
  ApiHomeSection sse_decode_api_home_section(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_videos = sse_decode_list_api_video_card(deserializer);
    return ApiHomeSection(name: var_name, videos: var_videos);
  }

  @protected
  ApiMyListInfo sse_decode_api_my_list_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_isWatchLater = sse_decode_bool(deserializer);
    var var_items = sse_decode_list_api_my_list_item(deserializer);
    return ApiMyListInfo(isWatchLater: var_isWatchLater, items: var_items);
  }

  @protected
  ApiMyListItem sse_decode_api_my_list_item(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_code = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_isSelected = sse_decode_bool(deserializer);
    return ApiMyListItem(
      code: var_code,
      title: var_title,
      isSelected: var_isSelected,
    );
  }

  @protected
  ApiPlayHistory sse_decode_api_play_history(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_videoId = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_coverUrl = sse_decode_String(deserializer);
    var var_progress = sse_decode_f_32(deserializer);
    var var_duration = sse_decode_u_32(deserializer);
    var var_lastPlayedAt = sse_decode_i_64(deserializer);
    return ApiPlayHistory(
      videoId: var_videoId,
      title: var_title,
      coverUrl: var_coverUrl,
      progress: var_progress,
      duration: var_duration,
      lastPlayedAt: var_lastPlayedAt,
    );
  }

  @protected
  ApiPlayHistoryList sse_decode_api_play_history_list(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_items = sse_decode_list_api_play_history(deserializer);
    var var_total = sse_decode_u_32(deserializer);
    var var_page = sse_decode_u_32(deserializer);
    var var_hasNext = sse_decode_bool(deserializer);
    return ApiPlayHistoryList(
      items: var_items,
      total: var_total,
      page: var_page,
      hasNext: var_hasNext,
    );
  }

  @protected
  ApiPlaylistInfo sse_decode_api_playlist_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_opt_String(deserializer);
    var var_videos = sse_decode_list_api_video_card(deserializer);
    return ApiPlaylistInfo(name: var_name, videos: var_videos);
  }

  @protected
  ApiSearchFilters sse_decode_api_search_filters(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_query = sse_decode_opt_String(deserializer);
    var var_genre = sse_decode_opt_String(deserializer);
    var var_tags = sse_decode_list_String(deserializer);
    var var_broadMatch = sse_decode_bool(deserializer);
    var var_sort = sse_decode_opt_String(deserializer);
    var var_year = sse_decode_opt_String(deserializer);
    var var_month = sse_decode_opt_String(deserializer);
    var var_date = sse_decode_opt_String(deserializer);
    var var_duration = sse_decode_opt_String(deserializer);
    var var_page = sse_decode_u_32(deserializer);
    return ApiSearchFilters(
      query: var_query,
      genre: var_genre,
      tags: var_tags,
      broadMatch: var_broadMatch,
      sort: var_sort,
      year: var_year,
      month: var_month,
      date: var_date,
      duration: var_duration,
      page: var_page,
    );
  }

  @protected
  ApiSearchResult sse_decode_api_search_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_videos = sse_decode_list_api_video_card(deserializer);
    var var_total = sse_decode_u_32(deserializer);
    var var_page = sse_decode_u_32(deserializer);
    var var_hasNext = sse_decode_bool(deserializer);
    return ApiSearchResult(
      videos: var_videos,
      total: var_total,
      page: var_page,
      hasNext: var_hasNext,
    );
  }

  @protected
  ApiSeriesInfo sse_decode_api_series_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_videos = sse_decode_list_api_series_video(deserializer);
    var var_currentIndex = sse_decode_u_32(deserializer);
    return ApiSeriesInfo(
      id: var_id,
      title: var_title,
      videos: var_videos,
      currentIndex: var_currentIndex,
    );
  }

  @protected
  ApiSeriesVideo sse_decode_api_series_video(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_coverUrl = sse_decode_String(deserializer);
    var var_episode = sse_decode_String(deserializer);
    return ApiSeriesVideo(
      id: var_id,
      title: var_title,
      coverUrl: var_coverUrl,
      episode: var_episode,
    );
  }

  @protected
  ApiSubscriptionsPage sse_decode_api_subscriptions_page(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_authors = sse_decode_list_api_author_info(deserializer);
    var var_videos = sse_decode_list_api_video_card(deserializer);
    var var_page = sse_decode_u_32(deserializer);
    var var_hasNext = sse_decode_bool(deserializer);
    return ApiSubscriptionsPage(
      authors: var_authors,
      videos: var_videos,
      page: var_page,
      hasNext: var_hasNext,
    );
  }

  @protected
  ApiSyncStatus sse_decode_api_sync_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_mergedCount = sse_decode_i_32(deserializer);
        var var_uploaded = sse_decode_bool(deserializer);
        return ApiSyncStatus_Success(
          mergedCount: var_mergedCount,
          uploaded: var_uploaded,
        );
      case 1:
        return ApiSyncStatus_DecryptionFailed();
      case 2:
        return ApiSyncStatus_NeedNewKey();
      case 3:
        var var_message = sse_decode_String(deserializer);
        return ApiSyncStatus_NetworkError(message: var_message);
      case 4:
        return ApiSyncStatus_NotConfigured();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ApiTagGroup sse_decode_api_tag_group(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_tags = sse_decode_list_api_filter_option(deserializer);
    return ApiTagGroup(name: var_name, tags: var_tags);
  }

  @protected
  ApiUserInfo sse_decode_api_user_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_avatarUrl = sse_decode_opt_String(deserializer);
    var var_isLoggedIn = sse_decode_bool(deserializer);
    return ApiUserInfo(
      id: var_id,
      name: var_name,
      avatarUrl: var_avatarUrl,
      isLoggedIn: var_isLoggedIn,
    );
  }

  @protected
  ApiVideoCard sse_decode_api_video_card(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_coverUrl = sse_decode_String(deserializer);
    var var_duration = sse_decode_opt_String(deserializer);
    var var_views = sse_decode_opt_String(deserializer);
    var var_uploadDate = sse_decode_opt_String(deserializer);
    var var_authorName = sse_decode_opt_String(deserializer);
    var var_tags = sse_decode_list_String(deserializer);
    return ApiVideoCard(
      id: var_id,
      title: var_title,
      coverUrl: var_coverUrl,
      duration: var_duration,
      views: var_views,
      uploadDate: var_uploadDate,
      authorName: var_authorName,
      tags: var_tags,
    );
  }

  @protected
  ApiVideoDetail sse_decode_api_video_detail(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_chineseTitle = sse_decode_opt_String(deserializer);
    var var_coverUrl = sse_decode_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_duration = sse_decode_opt_String(deserializer);
    var var_views = sse_decode_opt_String(deserializer);
    var var_likePercent = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_dislikePercent = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_likesCount = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_dislikesCount = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_uploadDate = sse_decode_opt_String(deserializer);
    var var_author = sse_decode_opt_box_autoadd_api_author_info(deserializer);
    var var_tags = sse_decode_list_String(deserializer);
    var var_qualities = sse_decode_list_api_video_quality(deserializer);
    var var_series = sse_decode_opt_box_autoadd_api_series_info(deserializer);
    var var_relatedVideos = sse_decode_list_api_video_card(deserializer);
    var var_formToken = sse_decode_opt_String(deserializer);
    var var_currentUserId = sse_decode_opt_String(deserializer);
    var var_isFav = sse_decode_bool(deserializer);
    var var_favTimes = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_playlist = sse_decode_opt_box_autoadd_api_playlist_info(
      deserializer,
    );
    var var_myList = sse_decode_opt_box_autoadd_api_my_list_info(deserializer);
    return ApiVideoDetail(
      id: var_id,
      title: var_title,
      chineseTitle: var_chineseTitle,
      coverUrl: var_coverUrl,
      description: var_description,
      duration: var_duration,
      views: var_views,
      likePercent: var_likePercent,
      dislikePercent: var_dislikePercent,
      likesCount: var_likesCount,
      dislikesCount: var_dislikesCount,
      uploadDate: var_uploadDate,
      author: var_author,
      tags: var_tags,
      qualities: var_qualities,
      series: var_series,
      relatedVideos: var_relatedVideos,
      formToken: var_formToken,
      currentUserId: var_currentUserId,
      isFav: var_isFav,
      favTimes: var_favTimes,
      playlist: var_playlist,
      myList: var_myList,
    );
  }

  @protected
  ApiVideoQuality sse_decode_api_video_quality(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_quality = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    return ApiVideoQuality(quality: var_quality, url: var_url);
  }

  @protected
  ApiWebDavSettings sse_decode_api_web_dav_settings(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_username = sse_decode_String(deserializer);
    var var_password = sse_decode_String(deserializer);
    var var_encryptionKey = sse_decode_String(deserializer);
    var var_autoSyncOnStart = sse_decode_bool(deserializer);
    var var_autoSyncInterval = sse_decode_i_32(deserializer);
    return ApiWebDavSettings(
      url: var_url,
      username: var_username,
      password: var_password,
      encryptionKey: var_encryptionKey,
      autoSyncOnStart: var_autoSyncOnStart,
      autoSyncInterval: var_autoSyncInterval,
    );
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  ApiAppSettings sse_decode_box_autoadd_api_app_settings(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_app_settings(deserializer));
  }

  @protected
  ApiAuthorInfo sse_decode_box_autoadd_api_author_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_author_info(deserializer));
  }

  @protected
  ApiBanner sse_decode_box_autoadd_api_banner(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_banner(deserializer));
  }

  @protected
  ApiCloudflareChallenge sse_decode_box_autoadd_api_cloudflare_challenge(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_cloudflare_challenge(deserializer));
  }

  @protected
  ApiMyListInfo sse_decode_box_autoadd_api_my_list_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_my_list_info(deserializer));
  }

  @protected
  ApiPlayHistory sse_decode_box_autoadd_api_play_history(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_play_history(deserializer));
  }

  @protected
  ApiPlaylistInfo sse_decode_box_autoadd_api_playlist_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_playlist_info(deserializer));
  }

  @protected
  ApiSearchFilters sse_decode_box_autoadd_api_search_filters(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_search_filters(deserializer));
  }

  @protected
  ApiSeriesInfo sse_decode_box_autoadd_api_series_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_series_info(deserializer));
  }

  @protected
  ApiUserInfo sse_decode_box_autoadd_api_user_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_user_info(deserializer));
  }

  @protected
  ApiWebDavSettings sse_decode_box_autoadd_api_web_dav_settings(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_web_dav_settings(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_32(deserializer));
  }

  @protected
  PlatformInt64 sse_decode_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_64(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  CacheInfo sse_decode_cache_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_coverCacheSize = sse_decode_u_64(deserializer);
    var var_videoCacheSize = sse_decode_u_64(deserializer);
    var var_totalSize = sse_decode_u_64(deserializer);
    return CacheInfo(
      coverCacheSize: var_coverCacheSize,
      videoCacheSize: var_videoCacheSize,
      totalSize: var_totalSize,
    );
  }

  @protected
  CacheSize sse_decode_cache_size(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_imageCacheBytes = sse_decode_u_64(deserializer);
    var var_imageCacheCount = sse_decode_u_64(deserializer);
    var var_webCacheCount = sse_decode_u_64(deserializer);
    return CacheSize(
      imageCacheBytes: var_imageCacheBytes,
      imageCacheCount: var_imageCacheCount,
      webCacheCount: var_webCacheCount,
    );
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiAuthorInfo> sse_decode_list_api_author_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiAuthorInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_author_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiComment> sse_decode_list_api_comment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiComment>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_comment(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiDownloadFolder> sse_decode_list_api_download_folder(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiDownloadFolder>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_download_folder(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiDownloadTask> sse_decode_list_api_download_task(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiDownloadTask>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_download_task(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiFilterOption> sse_decode_list_api_filter_option(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiFilterOption>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_filter_option(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiHomeSection> sse_decode_list_api_home_section(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiHomeSection>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_home_section(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiMyListItem> sse_decode_list_api_my_list_item(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiMyListItem>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_my_list_item(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiPlayHistory> sse_decode_list_api_play_history(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiPlayHistory>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_play_history(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiSeriesVideo> sse_decode_list_api_series_video(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiSeriesVideo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_series_video(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiTagGroup> sse_decode_list_api_tag_group(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiTagGroup>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_tag_group(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiVideoCard> sse_decode_list_api_video_card(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiVideoCard>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_video_card(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiVideoQuality> sse_decode_list_api_video_quality(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiVideoQuality>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_video_quality(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ApiAuthorInfo? sse_decode_opt_box_autoadd_api_author_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_api_author_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ApiBanner? sse_decode_opt_box_autoadd_api_banner(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_api_banner(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ApiCloudflareChallenge? sse_decode_opt_box_autoadd_api_cloudflare_challenge(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_api_cloudflare_challenge(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ApiMyListInfo? sse_decode_opt_box_autoadd_api_my_list_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_api_my_list_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ApiPlayHistory? sse_decode_opt_box_autoadd_api_play_history(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_api_play_history(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ApiPlaylistInfo? sse_decode_opt_box_autoadd_api_playlist_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_api_playlist_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ApiSeriesInfo? sse_decode_opt_box_autoadd_api_series_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_api_series_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ApiUserInfo? sse_decode_opt_box_autoadd_api_user_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_api_user_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PlatformInt64? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (String, String) sse_decode_record_string_string(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_AnyhowException(
    AnyhowException self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_StreamSink_api_download_task_Sse(
    RustStreamSink<ApiDownloadTask> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_download_task,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_api_export_progress_Sse(
    RustStreamSink<ApiExportProgress> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_api_export_progress,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_api_app_settings(
    ApiAppSettings self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.defaultQuality, serializer);
    sse_encode_u_32(self.downloadConcurrent, serializer);
    sse_encode_opt_String(self.proxyUrl, serializer);
    sse_encode_String(self.themeMode, serializer);
    sse_encode_String(self.language, serializer);
  }

  @protected
  void sse_encode_api_author_info(
    ApiAuthorInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_opt_String(self.avatarUrl, serializer);
    sse_encode_bool(self.isSubscribed, serializer);
  }

  @protected
  void sse_encode_api_banner(ApiBanner self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.title, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_String(self.picUrl, serializer);
    sse_encode_opt_String(self.videoCode, serializer);
  }

  @protected
  void sse_encode_api_cloudflare_challenge(
    ApiCloudflareChallenge self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_String(self.userAgent, serializer);
  }

  @protected
  void sse_encode_api_comment(ApiComment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.userName, serializer);
    sse_encode_opt_String(self.userAvatar, serializer);
    sse_encode_String(self.content, serializer);
    sse_encode_String(self.time, serializer);
    sse_encode_u_32(self.likes, serializer);
    sse_encode_u_32(self.dislikes, serializer);
    sse_encode_list_api_comment(self.replies, serializer);
    sse_encode_bool(self.hasMoreReplies, serializer);
  }

  @protected
  void sse_encode_api_comment_list(
    ApiCommentList self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_api_comment(self.comments, serializer);
    sse_encode_u_32(self.total, serializer);
    sse_encode_u_32(self.page, serializer);
    sse_encode_bool(self.hasNext, serializer);
  }

  @protected
  void sse_encode_api_download_folder(
    ApiDownloadFolder self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_i_64(self.createdAt, serializer);
  }

  @protected
  void sse_encode_api_download_status(
    ApiDownloadStatus self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ApiDownloadStatus_Pending():
        sse_encode_i_32(0, serializer);
      case ApiDownloadStatus_Downloading():
        sse_encode_i_32(1, serializer);
      case ApiDownloadStatus_Paused():
        sse_encode_i_32(2, serializer);
      case ApiDownloadStatus_Completed():
        sse_encode_i_32(3, serializer);
      case ApiDownloadStatus_Failed(error: final error):
        sse_encode_i_32(4, serializer);
        sse_encode_String(error, serializer);
    }
  }

  @protected
  void sse_encode_api_download_task(
    ApiDownloadTask self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.videoId, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.coverUrl, serializer);
    sse_encode_opt_String(self.coverPath, serializer);
    sse_encode_opt_String(self.authorId, serializer);
    sse_encode_opt_String(self.authorName, serializer);
    sse_encode_opt_String(self.authorAvatarUrl, serializer);
    sse_encode_opt_String(self.authorAvatarPath, serializer);
    sse_encode_String(self.quality, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_list_String(self.tags, serializer);
    sse_encode_api_download_status(self.status, serializer);
    sse_encode_f_32(self.progress, serializer);
    sse_encode_u_64(self.downloadedBytes, serializer);
    sse_encode_u_64(self.totalBytes, serializer);
    sse_encode_u_64(self.speed, serializer);
    sse_encode_i_64(self.createdAt, serializer);
    sse_encode_opt_String(self.filePath, serializer);
    sse_encode_opt_String(self.folderId, serializer);
  }

  @protected
  void sse_encode_api_export_progress(
    ApiExportProgress self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.totalFiles, serializer);
    sse_encode_u_32(self.doneFiles, serializer);
    sse_encode_opt_String(self.currentFile, serializer);
    sse_encode_u_64(self.currentBytes, serializer);
    sse_encode_u_64(self.currentTotalBytes, serializer);
    sse_encode_bool(self.done, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_api_favorite_list(
    ApiFavoriteList self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_api_video_card(self.videos, serializer);
    sse_encode_u_32(self.total, serializer);
    sse_encode_u_32(self.page, serializer);
    sse_encode_bool(self.hasNext, serializer);
  }

  @protected
  void sse_encode_api_filter_option(
    ApiFilterOption self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.value, serializer);
    sse_encode_String(self.label, serializer);
  }

  @protected
  void sse_encode_api_filter_options(
    ApiFilterOptions self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_api_filter_option(self.genres, serializer);
    sse_encode_list_api_tag_group(self.tags, serializer);
    sse_encode_list_api_filter_option(self.sorts, serializer);
    sse_encode_list_api_filter_option(self.years, serializer);
    sse_encode_list_api_filter_option(self.durations, serializer);
  }

  @protected
  void sse_encode_api_home_page(ApiHomePage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.formToken, serializer);
    sse_encode_opt_String(self.avatarUrl, serializer);
    sse_encode_opt_String(self.username, serializer);
    sse_encode_opt_box_autoadd_api_banner(self.banner, serializer);
    sse_encode_list_api_video_card(self.latestRelease, serializer);
    sse_encode_list_api_video_card(self.latestUpload, serializer);
    sse_encode_list_api_home_section(self.sections, serializer);
  }

  @protected
  void sse_encode_api_home_section(
    ApiHomeSection self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_list_api_video_card(self.videos, serializer);
  }

  @protected
  void sse_encode_api_my_list_info(
    ApiMyListInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.isWatchLater, serializer);
    sse_encode_list_api_my_list_item(self.items, serializer);
  }

  @protected
  void sse_encode_api_my_list_item(
    ApiMyListItem self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.code, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_bool(self.isSelected, serializer);
  }

  @protected
  void sse_encode_api_play_history(
    ApiPlayHistory self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.videoId, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.coverUrl, serializer);
    sse_encode_f_32(self.progress, serializer);
    sse_encode_u_32(self.duration, serializer);
    sse_encode_i_64(self.lastPlayedAt, serializer);
  }

  @protected
  void sse_encode_api_play_history_list(
    ApiPlayHistoryList self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_api_play_history(self.items, serializer);
    sse_encode_u_32(self.total, serializer);
    sse_encode_u_32(self.page, serializer);
    sse_encode_bool(self.hasNext, serializer);
  }

  @protected
  void sse_encode_api_playlist_info(
    ApiPlaylistInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.name, serializer);
    sse_encode_list_api_video_card(self.videos, serializer);
  }

  @protected
  void sse_encode_api_search_filters(
    ApiSearchFilters self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.query, serializer);
    sse_encode_opt_String(self.genre, serializer);
    sse_encode_list_String(self.tags, serializer);
    sse_encode_bool(self.broadMatch, serializer);
    sse_encode_opt_String(self.sort, serializer);
    sse_encode_opt_String(self.year, serializer);
    sse_encode_opt_String(self.month, serializer);
    sse_encode_opt_String(self.date, serializer);
    sse_encode_opt_String(self.duration, serializer);
    sse_encode_u_32(self.page, serializer);
  }

  @protected
  void sse_encode_api_search_result(
    ApiSearchResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_api_video_card(self.videos, serializer);
    sse_encode_u_32(self.total, serializer);
    sse_encode_u_32(self.page, serializer);
    sse_encode_bool(self.hasNext, serializer);
  }

  @protected
  void sse_encode_api_series_info(
    ApiSeriesInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_list_api_series_video(self.videos, serializer);
    sse_encode_u_32(self.currentIndex, serializer);
  }

  @protected
  void sse_encode_api_series_video(
    ApiSeriesVideo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.coverUrl, serializer);
    sse_encode_String(self.episode, serializer);
  }

  @protected
  void sse_encode_api_subscriptions_page(
    ApiSubscriptionsPage self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_api_author_info(self.authors, serializer);
    sse_encode_list_api_video_card(self.videos, serializer);
    sse_encode_u_32(self.page, serializer);
    sse_encode_bool(self.hasNext, serializer);
  }

  @protected
  void sse_encode_api_sync_status(
    ApiSyncStatus self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ApiSyncStatus_Success(
        mergedCount: final mergedCount,
        uploaded: final uploaded,
      ):
        sse_encode_i_32(0, serializer);
        sse_encode_i_32(mergedCount, serializer);
        sse_encode_bool(uploaded, serializer);
      case ApiSyncStatus_DecryptionFailed():
        sse_encode_i_32(1, serializer);
      case ApiSyncStatus_NeedNewKey():
        sse_encode_i_32(2, serializer);
      case ApiSyncStatus_NetworkError(message: final message):
        sse_encode_i_32(3, serializer);
        sse_encode_String(message, serializer);
      case ApiSyncStatus_NotConfigured():
        sse_encode_i_32(4, serializer);
    }
  }

  @protected
  void sse_encode_api_tag_group(ApiTagGroup self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_list_api_filter_option(self.tags, serializer);
  }

  @protected
  void sse_encode_api_user_info(ApiUserInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_opt_String(self.avatarUrl, serializer);
    sse_encode_bool(self.isLoggedIn, serializer);
  }

  @protected
  void sse_encode_api_video_card(ApiVideoCard self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.coverUrl, serializer);
    sse_encode_opt_String(self.duration, serializer);
    sse_encode_opt_String(self.views, serializer);
    sse_encode_opt_String(self.uploadDate, serializer);
    sse_encode_opt_String(self.authorName, serializer);
    sse_encode_list_String(self.tags, serializer);
  }

  @protected
  void sse_encode_api_video_detail(
    ApiVideoDetail self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_opt_String(self.chineseTitle, serializer);
    sse_encode_String(self.coverUrl, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_opt_String(self.duration, serializer);
    sse_encode_opt_String(self.views, serializer);
    sse_encode_opt_box_autoadd_u_32(self.likePercent, serializer);
    sse_encode_opt_box_autoadd_u_32(self.dislikePercent, serializer);
    sse_encode_opt_box_autoadd_u_32(self.likesCount, serializer);
    sse_encode_opt_box_autoadd_u_32(self.dislikesCount, serializer);
    sse_encode_opt_String(self.uploadDate, serializer);
    sse_encode_opt_box_autoadd_api_author_info(self.author, serializer);
    sse_encode_list_String(self.tags, serializer);
    sse_encode_list_api_video_quality(self.qualities, serializer);
    sse_encode_opt_box_autoadd_api_series_info(self.series, serializer);
    sse_encode_list_api_video_card(self.relatedVideos, serializer);
    sse_encode_opt_String(self.formToken, serializer);
    sse_encode_opt_String(self.currentUserId, serializer);
    sse_encode_bool(self.isFav, serializer);
    sse_encode_opt_box_autoadd_i_32(self.favTimes, serializer);
    sse_encode_opt_box_autoadd_api_playlist_info(self.playlist, serializer);
    sse_encode_opt_box_autoadd_api_my_list_info(self.myList, serializer);
  }

  @protected
  void sse_encode_api_video_quality(
    ApiVideoQuality self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.quality, serializer);
    sse_encode_String(self.url, serializer);
  }

  @protected
  void sse_encode_api_web_dav_settings(
    ApiWebDavSettings self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_String(self.username, serializer);
    sse_encode_String(self.password, serializer);
    sse_encode_String(self.encryptionKey, serializer);
    sse_encode_bool(self.autoSyncOnStart, serializer);
    sse_encode_i_32(self.autoSyncInterval, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_api_app_settings(
    ApiAppSettings self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_app_settings(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_author_info(
    ApiAuthorInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_author_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_banner(
    ApiBanner self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_banner(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_cloudflare_challenge(
    ApiCloudflareChallenge self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_cloudflare_challenge(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_my_list_info(
    ApiMyListInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_my_list_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_play_history(
    ApiPlayHistory self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_play_history(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_playlist_info(
    ApiPlaylistInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_playlist_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_search_filters(
    ApiSearchFilters self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_search_filters(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_series_info(
    ApiSeriesInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_series_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_user_info(
    ApiUserInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_user_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_web_dav_settings(
    ApiWebDavSettings self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_web_dav_settings(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_64(
    PlatformInt64 self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_cache_info(CacheInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.coverCacheSize, serializer);
    sse_encode_u_64(self.videoCacheSize, serializer);
    sse_encode_u_64(self.totalSize, serializer);
  }

  @protected
  void sse_encode_cache_size(CacheSize self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.imageCacheBytes, serializer);
    sse_encode_u_64(self.imageCacheCount, serializer);
    sse_encode_u_64(self.webCacheCount, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_author_info(
    List<ApiAuthorInfo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_author_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_comment(
    List<ApiComment> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_comment(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_download_folder(
    List<ApiDownloadFolder> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_download_folder(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_download_task(
    List<ApiDownloadTask> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_download_task(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_filter_option(
    List<ApiFilterOption> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_filter_option(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_home_section(
    List<ApiHomeSection> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_home_section(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_my_list_item(
    List<ApiMyListItem> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_my_list_item(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_play_history(
    List<ApiPlayHistory> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_play_history(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_series_video(
    List<ApiSeriesVideo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_series_video(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_tag_group(
    List<ApiTagGroup> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_tag_group(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_video_card(
    List<ApiVideoCard> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_video_card(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_video_quality(
    List<ApiVideoQuality> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_video_quality(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_string_string(
    List<(String, String)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_api_author_info(
    ApiAuthorInfo? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_api_author_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_api_banner(
    ApiBanner? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_api_banner(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_api_cloudflare_challenge(
    ApiCloudflareChallenge? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_api_cloudflare_challenge(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_api_my_list_info(
    ApiMyListInfo? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_api_my_list_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_api_play_history(
    ApiPlayHistory? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_api_play_history(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_api_playlist_info(
    ApiPlaylistInfo? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_api_playlist_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_api_series_info(
    ApiSeriesInfo? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_api_series_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_api_user_info(
    ApiUserInfo? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_api_user_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_64(
    PlatformInt64? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_record_string_string(
    (String, String) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }
}
